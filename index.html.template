<!DOCTYPE html>
<html>

<head>
	<title>FactorioMaps</title>
	<link href="lib/favicon.ico" rel="icon" type="image/x-icon">
	<meta name="og:image" content="lib/t92kw.png" />
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="stylesheet" href="lib/leaflet.css" />

	<style type="text/css">
		html {
			height: 100%
		}

		body {
			height: 100%;
			margin: 0px;
			padding: 0px
		}

		#map {
			height: 100%;
			z-index: 0;
			background-color: rgb(27, 44, 51) !important;
		}

		#gmnoprint {
			width: auto;
		}

		/* DOWN BUTTON CSS */
		#downBtn {
			position: fixed;
			/* Fixed/sticky position */
			bottom: 0px;
			/* Place the button at the bottom of the page */
			right: 50%;
			transform: translate(50%, 0);
			z-index: 99;
			/* Make sure it does not overlap */
			border: none;
			/* Remove borders */
			outline: none;
			/* Remove outline */
			background-color: chocolate;
			/* Set a background color */
			color: white;
			/* Text color */
			cursor: pointer;
			/* Add a mouse pointer on hover */
			padding: 5px;
			/* Some padding */
			border-radius: 7px;
			/* Rounded corners */
			font-size: 18px;
			/* Increase font size */
		}

		#downBtn:hover {
			background-color: #555;
			/* Add a dark-grey background on hover */
		}

		/* FANCY DOWNLOAD CSS */
		#modal {
			display: none;
			position: absolute;
			top: 150px;
			bottom: 30px;
			background-color: rgb(27, 45, 51);
			padding: 20px;
			z-index: 100;
			width: 400px;
			right: 50%;
			margin-right: -200px;
			border: none;
			border-radius: 5px;
			color: #C6FFFD;
		}

		#modal.open {
			display: block;
		}

		#modal ul li {
			list-style-type: none;
			margin-bottom: 5px;
		}

		#modal .close {
			cursor: pointer;
			float: right;
			margin-top: -20px;
		}

		#modal .title {
			font-size: 2em;
			text-align: center;
			margin-bottom: 15px;
		}

		#modal .mapLayerLink {
			float: right;
			padding: 0px 25px;
			background-color: chocolate;
			color: #CFFFFD;
			border-radius: 8px;
			line-height: 35px;
		}

		#modal .mapLayerLink.disabled {
			background-color: grey;
			cursor: not-allowed;
		}

		#modal .mapLayerLink:hover {
			background-color: #555;
		}

		hr.clear {
			clear: both;
			float: none;
			border: 0;
			width: 0;
			height: 0;
			padding: 0;
			margin: 0;
		}

		#modal .body {
			overflow-y: auto;
			max-height: 92%;
		}

		/* END FANCY DOWNLOAD CSS */
		#nextBtn {
			position: fixed; /* Fixed/sticky position */
			top: 50%; /* Place the button at the bottom of the page */
			right: -38px; /* Place the button 30px from the right */
			z-index: 99; /* Make sure it does not overlap */
			border: none; /* Remove borders */
			outline: none; /* Remove outline */
			background-color: chocolate; /* Set a background color */
			color: white; /* Text color */
			cursor: pointer; /* Add a mouse pointer on hover */
			padding: 6px; /* Some padding */
			border-radius: 6px; /* Rounded corners */
			font-size: 18px; /* Increase font size */
			transform: rotate(90deg);
		}

		#nextBtn:hover {
			background-color: #555; /* Add a dark-grey background on hover */
		}
		#prevBtn {
			position: fixed; /* Fixed/sticky position */
			top: 50%; /* Place the button at the bottom of the page */
			left: -35px; /* Place the button 30px from the right */
			z-index: 99; /* Make sure it does not overlap */
			border: none; /* Remove borders */
			outline: none; /* Remove outline */
			background-color: chocolate; /* Set a background color */
			color: white; /* Text color */
			cursor: pointer; /* Add a mouse pointer on hover */
			padding: 6px; /* Some padding */
			border-radius: 6px; /* Rounded corners */
			font-size: 18px; /* Increase font size */
			transform: rotate(-90deg);
		}

		#prevBtn:hover {
			background-color: #555; /* Add a dark-grey background on hover */
		}

		img.leaflet-tile.leaflet-tile-loaded {
			image-rendering: pixelated;
		}


		.map-marker {
			width: 32px;
			height: 32px;
			margin-left: -16px;
			margin-top: -16px;
			display: block;
		}
		.map-marker-text {
			color: white;
			font-size: 1em;
			margin: -6px -32px;
			text-align: center;
			display: block;
			width: 96px;
		}

		map-marker-default:before {
			content: "";
			display: inline-block;
			background-color: red;
			width: 19px;
			height: 19px;
			border: solid 6.5px #0F0;
			border-radius: 16px;
		}
		

	</style>
	<script src="lib/leaflet-src.min.js"></script>
	<link href='lib/Control.FullScreen.css' rel='stylesheet' />
	<script src='lib/Control.FullScreen.min.js'></script>
	<script src='lib/naturalsort.min.js'></script>





	<script src="lib/jquery.min.js"></script>
	
	<link rel="stylesheet" href="lib/jquery-ui.css">
	<script src="lib/jquery-ui.min.js"></script>

	<link rel="stylesheet" href="lib/Control.Opacity.css" />
	<script src="lib/Control.Opacity.js" ></script>


	<script src="mapInfo.js"></script>
</head>

<body>
	<div id="map" style="background: #1B2D33;"></div>
	<script>
		"use strict";
		let DEBUG = false;
		


		let TILESPERIMAGE = 16

		//let _getTileUrl = L.TileLayer.prototype.getTileUrl;
		//L.TileLayer.prototype.getTileUrl = function(coords) { return _getTileUrl.call(this, {x: coords.x - 1 * Math.pow(2, coords.z - 2), y: coords.y, z: coords.z}); };

		L.TileLayer.prototype.getTileUrl = function(c) {
			let mapIndex = this.tileIndex[c.z] && this.tileIndex[c.z][c.y] && this.tileIndex[c.z][c.y][c.x];
			if (isNaN(mapIndex))
				mapIndex = this.tileIndex.fallback;
			if (isNaN(mapIndex))
				return "";
			return "Images/" + mapInfo.maps[mapIndex].path + "/" + this.surface + "/" + this.daytime + "/" + c.z + "/" + c.x + "/" + c.y + ".jpg";
		}

		//TODO: iterate over surfaces
		//let surface = Object.keys(mapInfo.maps[0].surfaces)[0];
		

		let layers = [], saves = [], countAvailableSaves = 0, layersByTimestamp = [];
		let globalTileIndex = {};
		let globalTileNightIndex = {};


		for (let i = 0; i < mapInfo.maps.length; i++) {
			if (DEBUG) {
				globalTileIndex = {};
				globalTileNightIndex = {};
			}

			let map = mapInfo.maps[i];
			layersByTimestamp[i] = {};

			for (const surface of Object.keys(map.surfaces)) {
				let layer = map.surfaces[surface];
				if (!(surface in layers))
					layers[surface] = {};
				layers[surface][i] = {};

				TILESPERIMAGE = layer.zoom.max == 20 ? 16 : 8;

				if (!globalTileNightIndex[surface]) {
					globalTileNightIndex[surface] = layer.chunks ? {} : {fallback: i};
					globalTileIndex[surface] = layer.chunks ? {} : {fallback: i};
				}
				for (let z = layer.zoom.min; z <= layer.zoom.max; z++)
					if (!globalTileNightIndex[surface][z]) {
						globalTileNightIndex[surface][z] = {};
						globalTileIndex[surface][z] = {};
					}
				(layer.chunks || "").split('=').forEach(function(row) {
					function B64Parse(offset) {
						return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(row[offset])
						+ 64 * "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(row[offset+1])
						+64*64*"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(row[offset+2])
						- 2**16;
					}

					console.assert(row.length % 3 == 0); //corrupted data, prevent infinite loop
					let j = 3, y = B64Parse(0) - 2**17;
					
					if (!globalTileNightIndex[surface][layer.zoom.max][y]){
						globalTileNightIndex[surface][layer.zoom.max][y] = {};
						globalTileIndex[surface][layer.zoom.max][y] = {};
					}
					while (j < row.length) {
						let stop = B64Parse(j + 3)
						let start = B64Parse(j);
						let mode = start > 2**16;
						for (let x = start - mode*2**17; x < (stop - (stop>2**16)*2**17); x++) {
							globalTileNightIndex[surface][layer.zoom.max][y][x] = i;
							if (mode)
								globalTileIndex[surface][layer.zoom.max][y][x] = i;
							for (let z = 1; z <= layer.zoom.max - layer.zoom.min; z++)  {
								if (!globalTileNightIndex[surface][layer.zoom.max-z][y >> z]) {
									globalTileNightIndex[surface][layer.zoom.max-z][y >> z] = {};
									globalTileIndex[surface][layer.zoom.max-z][y >> z] = {};
								}
								if ((mode ? globalTileIndex : globalTileNightIndex)[surface][layer.zoom.max-z][y >> z][x >> z] == i)
									break;
								globalTileNightIndex[surface][layer.zoom.max-z][y >> z][x >> z] = i;
								if (mode)
									globalTileIndex[surface][layer.zoom.max-z][y >> z][x >> z] = i;
							}
						}
						j += mode == stop > 2**16 ? 6 : 3;
					}
				});

				let tileIndex = { fallback: globalTileIndex[surface].fallback };
				for (const z in globalTileIndex[surface]) {
					if (z == "fallback")
						continue;
					tileIndex[z] = {};
					for (const y in globalTileIndex[surface][z]) {
						tileIndex[z][y] = {};
						for (const x in globalTileIndex[surface][z][y])
							tileIndex[z][y][x] = globalTileIndex[surface][z][y][x];
					}
				}
				let tileNightIndex = { fallback: globalTileNightIndex[surface].fallback };
				for (const z in globalTileNightIndex[surface]) {
					if (z == "fallback")
						continue;
					tileNightIndex[z] = {};
					for (const y in globalTileNightIndex[surface][z]) {
						tileNightIndex[z][y] = {};
						for (const x in globalTileNightIndex[surface][z][y])
							tileNightIndex[z][y][x] = globalTileNightIndex[surface][z][y][x];
					}
				}


				layersByTimestamp[i][surface] = {};
				map.surfaces[surface].layers = {};

				["day", "night"].forEach(function(daytime) {
					if (layer[daytime] == "true") {
						let LLayer = L.tileLayer(undefined, {
							id: layer.path,
							attribution: '<a href="https://github.com/L0laapk3/FactorioMaps">FactorioMaps</a>',
							minNativeZoom: DEBUG ? 20 : layer.zoom.min,
							maxNativeZoom: layer.zoom.max,
							minZoom: layer.zoom.min >= 1 ? layer.zoom.min - 1 : 1,
							maxZoom: 23, //layer.zoom.max + 2,
							noWrap: true,
							tileSize: 512 / window.devicePixelRatio,
							keepBuffer: 3
						});
						LLayer.surface = surface;
						LLayer.daytime = daytime;
						LLayer.path = map.path;
						LLayer.tileIndex = daytime == "day" ? tileIndex : tileNightIndex;


						map.surfaces[surface].layers[daytime] = layersByTimestamp[i][surface][daytime] = layers[surface][i][daytime] = LLayer;
					}
				});



				if (layer.save && layer.save.download) {
					saves.push({
						layer: layer.save.name || layer.name,
						url: layer.save.url
					});
					if (layer.save.url) {
						countAvailableSaves++;
					}
				}




				layers[surface][i].tags = layer.tags;
				// todo: group tags.. ?
				for (const tag in layer.tags) {
					//console.log(tag);
				}

			}
		}









		/* EDIT */
		if (countAvailableSaves > 0 || mapInfo.links && mapInfo.links.save) {
			let btn = document.createElement("a"), modal = document.getElementById("modal"), ulContainer = document.getElementById("save-download-container"), modalClose = modal.getElementsByClassName("close")[0], opened = false, built = false;
			btn.id = 'downBtn';
			btn.appendChild(document.createTextNode("Download Save"))
			if (saves.length <= 1) {
				//Act like a download link
				btn.href = saves.length === 1 ? saves[0].url : m.links.save;
				btn.target = '_blank';
			} else {
				btn.addEventListener('click', function () {
					if (!opened) {
						if (!built) {
							//Empty the modal, re-create modal content and display it
							while (ulContainer.lastChild) {
								ulContainer.removeChild(ulContainer.lastChild);
							}
							for (const i in saves) {
								if (saves.hasOwnProperty(i)) {
									let saveObj = saves[i];
									let li = document.createElement("li"), a = document.createElement("a"), span = document.createElement("span"), hr = document.createElement("hr");
									hr.classList.add("clear");
									a.classList.add("mapLayerLink");
									li.classList.add("mapLayer");
									a.appendChild(document.createTextNode("Download"));

									a.target = "_blank";
									if (!saveObj.url) {
										a.setAttribute("disabled", "disabled");
										a.classList.add("disabled");
									} else {
										a.href = saveObj.url;
									}
									span.classList.add("mapLayerName")
									span.appendChild(document.createTextNode(saveObj.layer));
									li.appendChild(span);
									li.appendChild(a);
									li.appendChild(hr);
									ulContainer.appendChild(li);
								}
							}
							modal.classList.add("open");
							opened = true;
						}
					}
				});
				modalClose.addEventListener("click", function () {
					if (opened) {
						modal.classList.remove("open");
						opened = false;
					}
				});
			}
			document.getElementById("buttonAnchor").appendChild(btn);
		}

		let nightOpacity = 0;
		const someSurfaces = mapInfo.maps[mapInfo.maps.length-1].surfaces;
		let currentSurface = "nauvis" in someSurfaces ? "nauvis" : Object.keys(someSurfaces).sort()[0]
		let loadLayer = someSurfaces[currentSurface].layers;
		let timestamp = (loadLayer.day || loadLayer.night).path;

		let startZ = 16, startX = 0, startY = 0;
		let coordScale = 2**19 / 16 * window.devicePixelRatio;
		try {
			let split = window.location.hash.substr(1).split('/').map(decodeURIComponent);
			if (window.location.hash[0] == '#' && split[0] == "1") {
				currentSurface = split[1];
				loadLayer = someSurfaces[currentSurface].layers;
				if (!isNaN(parseInt(split[2]))) startZ = parseInt(split[2]);
				startX = parseInt(split[3]) / coordScale || startX;
				startY = parseInt(split[4]) / coordScale || startY;
				nightOpacity = parseFloat(split[5]) || nightOpacity;
				if (!isNaN(parseInt(split[6]))) {
					timestamp = split[6];
					if (!isNaN(parseInt(split[7])))
						timestamp += "-" + split[7];
				}

						
			}
		} catch (_) {
				window.location.href = "#";
				window.location.reload();
		}
		
		let lastHash = "";
		function updateHash() {
			const path = [1, currentSurface, map.getZoom(), Math.round(map.getCenter().lat * coordScale), Math.round(map.getCenter().lng * coordScale), nightOpacity, timestamp.replace('-', '/')];
			console.log(path);
			let hash = "#" + path.join("/");
			if (hash != lastHash) {
				lastHash = hash;
				window.location.replace(hash);
			}
		}
		window.onhashchange = function() {
			if (lastHash != window.location.hash)
				window.location.reload();
		}


		let leafletLayers = [];
		let map = L.map('map', {
			center: [startX, startY],
			zoom: startZ,
			layers: [],
			fadeAnimation: false,
			zoomAnimation: true,
			crs: L.CRS.Simple // the map is 2D by nature
		});
		map.on("zoomend moveend", updateHash);

		
		let daylightSlider, timeSlider;
		let mapLoadedBySlider = false;
		if (Object.values(layers).some(s => Object.values(s).some(l => l.day)) && Object.values(layers).some(s => Object.values(s).some(l => l.night))) {
			daylightSlider = new L.Control.opacitySlider({
				position: "bottomright",
				orientation: "horizontal",
				initial: nightOpacity,
				length: 135,
				gravitate: 7,
				labels: [ {name: "Day", position: 0, layers: Object.values(layers).map(s => Object.values(s).map(l => l.day)).flat()}, {name: "Nightvision", position: .42, gravitate: 5}, {name: "Night", position: 1, layers: Object.values(layers).map(s => Object.values(s).map(l => l.night)).flat()} ],
				onChange: function(value) {
					nightOpacity = Math.round(value * 100) / 100;
					updateHash();
				}
			});
			map.addControl(daylightSlider);
			mapLoadedBySlider = true;
		}





		
		
		
		if (layersByTimestamp.length > 1 && true) {
			let min = Math.min.apply(undefined, mapInfo.maps.map(l => parseInt(l.path)));
			let max = Math.max.apply(undefined, mapInfo.maps.map(l => parseInt(l.path)));
			let sliderHeight = Math.min(window.innerHeight * .8, Math.max(95, 45 * (layersByTimestamp.length - 1)));
			let timeLabels = layersByTimestamp.map(function(layer, i) {
				return {
					name: mapInfo.maps[i].path + "h",
					position: max == min ? i / (layersByTimestamp.length - 1) : i * 30/sliderHeight + (parseInt(mapInfo.maps[i].path) - min) / (max - min) * (1 - (layersByTimestamp.length - 1) * 30/sliderHeight),
					layers: Object.values(layer).map(s => ["day", "night"].map(n => s[n]).filter(l => l)).flat()
				}
			});


			
			let initialTime;
			for (let i = 0; i < timeLabels.length; i++) {
				if (parseFloat(timestamp) < parseInt(timeLabels[i].name)) {
					if (!i)
						initialTime = timeLabels[i].position;
					else
						initialTime = timeLabels[i].position - (timeLabels[i].position - timeLabels[i-1].position) * (parseInt(timeLabels[i].name) - parseFloat(timestamp)) / (parseInt(timeLabels[i].name) - parseInt(timeLabels[i-1].name));
					break;
				} else if (parseFloat(timestamp) == parseInt(timeLabels[i].name)) {
					let diff = parseInt(timeLabels[i].name.split("-")[1] || 0) - parseFloat(timestamp.split("-")[1] || 0);
					if (diff == 0) {
						initialTime = timeLabels[i].position;
						break;
					} else if (diff > 0) {
						initialTime = timeLabels[i].position - (timeLabels[i].position - timeLabels[i-1].position) * diff / (parseInt(timeLabels[i].name.split("-")[1] || 0) - parseInt(timeLabels[i-1].name.split("-")[1] || 0));
						break;
					}
				}
			}

			timeSlider = new L.Control.opacitySlider({
				position: "bottomright",
				orientation: "vertical",
				initial: initialTime,
				length: sliderHeight,
				evenSpacing: true,
				gravitate: 5,
				backdrop: false,
				labels: timeLabels,
				onChange: function(value, localValue, below, above) {
					if (!above)
						timestamp = below.name.slice(0, -1);
					else {
						let one = below.name.slice(0, -1).split("-");
						let two = above.name.slice(0, -1).split("-");
						if (one[0] == two[0])
							timestamp = one[0] + "-" + Math.round(((parseInt(one[1]) || 0) + localValue * ((parseInt(two[1]) || 0) - (parseInt(one[1]) || 0))) * 100) / 100;
						else
							timestamp = "" + Math.round((parseInt(one[0]) + localValue * (parseInt(two[0]) - parseInt(one[0]))) * 100) / 100;
					}
					updateHash();
				}
			});
			map.addControl(timeSlider);
			mapLoadedBySlider = true;
		}


		// nauvis ontop, other than that natural sort.
		let surfaceKeys = Object.keys(layers).filter(s => s != "nauvis").sort(naturalSort);
		if (Object.keys(layers).some(s => s == "nauvis"))
			surfaceKeys.unshift("nauvis")

		if (surfaceKeys.length > 1) {
			let surfaceSlider = new L.Control.layerRadioSelector({
				position: "bottomright",
				orientation: "vertical",
				initial: Math.max(0, surfaceKeys.indexOf(currentSurface)),
				length: (surfaceKeys.length-1)*30,
				evenSpacing: true,
				backdrop: false,
				labels: surfaceKeys.map((s, i) => { return {name: s, layers: Object.values(layers[s]).map(l => ["day", "night"].map(d => l[d])).flat()} }),
				onChange: function(index) {
					console.log(index, surfaceKeys);
					currentSurface = surfaceKeys[index];
					updateHash();
				}
			});
			map.addControl(surfaceSlider);
			mapLoadedBySlider = true;
		}



		if (!mapLoadedBySlider)
			map.addLayer(loadLayer.day || loadLayer.night);
		map.addControl(new L.Control.FullScreen().setPosition('bottomright'));
		map.zoomControl.setPosition('bottomleft')
		
		
		for (const surface of layers)
			for (const layer of Object.values(surface)) {
				layer.tags.sort((a, b) => a.position.y - b.position.y)
				for (const tag of layer.tags) {

					L.marker([-(tag.position.y - TILESPERIMAGE/2) / coordScale, (tag.position.x - TILESPERIMAGE/2) / coordScale], {
						icon: new L.DivIcon({
							className: 'map-tag',
							html: 	tag.iconPath ? '<img class="map-marker" src="' + tag.iconPath + '"/>' : '<map-marker-default class="map-marker"/>' +
									'<span class="map-marker-text">' + tag.text + '</span>'
						})
					}).addTo(map);
				}
		}

		setTimeout(_ => {
			daylightSlider.setLength(135 + Math.round(($(".leaflet-control-container > .leaflet-bottom.leaflet-right").width() - 10 - $(daylightSlider._container).outerWidth())*10)/10);
		});
		
	</script>
</body>

</html>
